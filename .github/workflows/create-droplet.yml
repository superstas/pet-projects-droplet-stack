name: Create Droplet

on:
  workflow_dispatch:
    inputs:
      domain_name:
        description: 'Domain name for the application (e.g., example.com)'
        required: true
        type: string
      region:
        description: 'DigitalOcean region (e.g., nyc1, sfo3, ams3, lon1, fra1, sgp1)'
        required: true
        type: choice
        options:
          - nyc1
          - nyc2
          - nyc3
          - sfo2
          - sfo3
          - ams3
          - sgp1
          - lon1
          - fra1
          - tor1
          - blr1
          - syd1
          - atl1
      app_port:
        description: 'Application port (default: 9000)'
        required: false
        type: number
        default: 9000
      metrics_path:
        description: 'Metrics endpoint path (default: /metrics)'
        required: false
        type: string
        default: '/metrics'
      ssh_authorized_keys:
        description: 'SSH public keys for admin user (one per line, optional - uses secret if not provided)'
        required: false
        type: string
      ssh_authorized_username:
        description: 'Username for SSH admin access (default: admin)'
        required: false
        type: string
        default: 'admin'
      ssh_port:
        description: 'SSH port for server access (default: 53222)'
        required: false
        type: number
        default: 53222

env:
  DROPLET_SIZE: s-1vcpu-512mb-10gb
  DROPLET_IMAGE: debian-12-x64
  DROPLET_TAG: managed-by-github

jobs:
  create-droplet:
    name: Create and Configure Droplet
    runs-on: ubuntu-latest
    permissions:
      contents: read   # Required for reading repository content
      actions: write   # Required for managing GitHub Actions Variables
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup metadata helpers
        run: |
          # Copy metadata helper functions to a temporary location
          cp infra/scripts/metadata-helpers.sh /tmp/metadata-helpers.sh
          chmod +x /tmp/metadata-helpers.sh
          echo "âœ“ Metadata helper functions ready"
      
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}
      
      - name: Validate inputs
        run: |
          echo "Validating inputs..."
          
          # Validate domain name (supports subdomains like test.example.com)
          if [[ ! "${{ inputs.domain_name }}" =~ ^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]]; then
            echo "Error: Invalid domain name format"
            echo "Domain must be a valid FQDN (e.g., example.com or test.example.com)"
            exit 1
          fi
          
          # Validate port
          if [ "${{ inputs.app_port }}" -lt 1024 ] || [ "${{ inputs.app_port }}" -gt 65535 ]; then
            echo "Error: Port must be between 1024 and 65535"
            exit 1
          fi
          
          echo "âœ“ All inputs are valid"
      
      - name: Validate SSH port
        run: |
          echo "Validating SSH port..."
          
          SSH_PORT="${{ inputs.ssh_port }}"
          
          # Check port range (1024-65535)
          # Ports below 1024 are system ports and include commonly reserved ports like 22 (default SSH), 80 (HTTP), 443 (HTTPS)
          if [ "$SSH_PORT" -lt 1024 ] || [ "$SSH_PORT" -gt 65535 ]; then
            echo "Error: SSH port must be between 1024 and 65535"
            echo "Provided: $SSH_PORT"
            exit 1
          fi
          
          echo "âœ“ SSH port $SSH_PORT is valid"
      
      - name: Generate droplet name
        id: droplet-name
        run: |
          # Generate a unique droplet name from domain
          DOMAIN="${{ inputs.domain_name }}"
          SANITIZED=$(echo "$DOMAIN" | sed 's/[^a-z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
          DROPLET_NAME="droplet-${SANITIZED}"
          echo "name=$DROPLET_NAME" >> $GITHUB_OUTPUT
          echo "Generated droplet name: $DROPLET_NAME"
      
      - name: Add SSH key to DigitalOcean
        id: ssh-key
        run: |
          # Check if SSH key already exists
          KEY_NAME="github-actions-${{ github.repository_owner }}"
          
          # Try to find existing key
          EXISTING_KEY_ID=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$KEY_NAME" | awk '{print $1}' || true)
          
          if [ -n "$EXISTING_KEY_ID" ]; then
            echo "SSH key already exists with ID: $EXISTING_KEY_ID"
            echo "key_id=$EXISTING_KEY_ID" >> $GITHUB_OUTPUT
          else
            # Add new SSH key
            echo "Adding new SSH key..."
            echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/ssh_key.pub
            
            KEY_ID=$(doctl compute ssh-key import "$KEY_NAME" \
              --public-key-file /tmp/ssh_key.pub \
              --format ID --no-header)
            
            echo "key_id=$KEY_ID" >> $GITHUB_OUTPUT
            echo "Added SSH key with ID: $KEY_ID"
            
            rm /tmp/ssh_key.pub
          fi
      
      - name: Prepare cloud-init with admin user
        run: |
          echo "Preparing cloud-init configuration..."
          
          # Determine which SSH keys to use
          if [ -n "${{ inputs.ssh_authorized_keys }}" ]; then
            ADMIN_SSH_KEYS="${{ inputs.ssh_authorized_keys }}"
          else
            ADMIN_SSH_KEYS="${{ secrets.SSH_PUBLIC_KEY }}"
          fi
          
          ADMIN_USERNAME="${{ inputs.ssh_authorized_username }}"
          SSH_PORT="${{ inputs.ssh_port }}"
          
          # Create temporary cloud-init with configured SSH port
          cp infra/templates/cloud-init.yml /tmp/cloud-init-custom.yml
          
          # Replace hardcoded SSH port with configured port
          sed -i "s/Port 53222/Port ${SSH_PORT}/" /tmp/cloud-init-custom.yml
          sed -i "s/ufw limit 53222\\/tcp/ufw limit ${SSH_PORT}\\/tcp/" /tmp/cloud-init-custom.yml
          
          # Add admin user configuration
          cat >> /tmp/cloud-init-custom.yml << EOF

          # Create admin user for server administration
          users:
            - name: ${ADMIN_USERNAME}
              groups: sudo
              shell: /bin/bash
              sudo: ['ALL=(ALL) NOPASSWD:ALL']
              ssh_authorized_keys:
          EOF
          
          # Add SSH keys (one per line)
          echo "$ADMIN_SSH_KEYS" | while IFS= read -r key; do
            if [ -n "$key" ]; then
              echo "      - $key" >> /tmp/cloud-init-custom.yml
            fi
          done
          
          echo "âœ“ Cloud-init prepared with admin user configuration"
          echo "âœ“ SSH port configured successfully"
      
      - name: Create droplet with cloud-init
        id: create-droplet
        run: |
          echo "Creating droplet..."
          
          # Create droplet and capture output
          DROPLET_ID=$(doctl compute droplet create "${{ steps.droplet-name.outputs.name }}" \
            --size "${{ env.DROPLET_SIZE }}" \
            --image "${{ env.DROPLET_IMAGE }}" \
            --region "${{ inputs.region }}" \
            --ssh-keys "${{ steps.ssh-key.outputs.key_id }}" \
            --tag-name "${{ env.DROPLET_TAG }}" \
            --user-data-file /tmp/cloud-init-custom.yml \
            --wait \
            --format ID \
            --no-header)
          
          echo "droplet_id=$DROPLET_ID" >> $GITHUB_OUTPUT
          echo "âœ“ Droplet created with ID: $DROPLET_ID"
      
      - name: Wait for droplet to be active and get IP
        id: droplet-ip
        run: |
          echo "Waiting for droplet to become active..."
          
          DROPLET_ID="${{ steps.create-droplet.outputs.droplet_id }}"
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
            
            if [ "$STATUS" = "active" ]; then
              echo "âœ“ Droplet is active"
              break
            fi
            
            echo "Droplet status: $STATUS (attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
            sleep 5
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Error: Droplet did not become active in time"
            exit 1
          fi
          
          # Get IP address
          IP_ADDRESS=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
          echo "ip=$IP_ADDRESS" >> $GITHUB_OUTPUT
          echo "âœ“ Droplet IP address resolved successfully"
      
      - name: Wait for SSH to be available
        run: |
          SSH_PORT="${{ inputs.ssh_port }}" > /dev/null 2>&1
          echo "Waiting for SSH to become available..."
          
          IP="${{ steps.droplet-ip.outputs.ip }}" > /dev/null 2>&1
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if timeout 5 bash -c "cat < /dev/null > /dev/tcp/$IP/$SSH_PORT" 2>/dev/null; then
              echo "âœ“ SSH is available"
              break
            fi
            
            echo "Waiting for SSH... (attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Error: SSH did not become available in time"
            exit 1
          fi
      
      - name: Setup SSH key for connection
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Add to known_hosts (suppress output to prevent IP/port exposure)
          ssh-keyscan -p ${{ inputs.ssh_port }} -H ${{ steps.droplet-ip.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Wait for cloud-init to complete
        run: |
          IP="${{ steps.droplet-ip.outputs.ip }}" > /dev/null 2>&1
          ADMIN_USER="${{ inputs.ssh_authorized_username }}" > /dev/null 2>&1
          
          echo "Waiting for cloud-init to complete..."
          echo "Using configured admin user"
          
          # Use cloud-init status --wait to wait for completion (with timeout)
          # This ensures all packages are installed AND all runcmd scripts have executed
          ssh -p ${{ inputs.ssh_port }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=3 \
            ${ADMIN_USER}@$IP \
            "sudo cloud-init status --wait --long" || {
              echo "Error: cloud-init did not complete successfully"
              echo "Checking cloud-init status..."
              ssh -p ${{ inputs.ssh_port }} \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o LogLevel=ERROR \
                ${ADMIN_USER}@$IP \
                "sudo cloud-init status --long" || true
              exit 1
            }
          
          echo "âœ“ Cloud-init completed successfully"
          
          # Verify nginx configuration exists
          echo "Verifying nginx configuration..."
          ssh -p ${{ inputs.ssh_port }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            ${ADMIN_USER}@$IP \
            "sudo test -f /etc/nginx/nginx.conf && sudo nginx -t" || {
              echo "Error: Nginx configuration is missing or invalid"
              exit 1
            }
          
          echo "âœ“ Nginx is properly configured"
      
      - name: Copy setup script to droplet
        run: |
          echo "Copying setup-application.sh to droplet..."
          ADMIN_USER="${{ inputs.ssh_authorized_username }}" > /dev/null 2>&1
          
          scp -P ${{ inputs.ssh_port }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            infra/scripts/setup-application.sh \
            ${ADMIN_USER}@${{ steps.droplet-ip.outputs.ip }}:/tmp/setup-application.sh
          
          echo "âœ“ Script copied successfully"
      
      - name: Run application setup script
        id: setup-app
        run: |
          echo "Running application setup..."
          ADMIN_USER="${{ inputs.ssh_authorized_username }}" > /dev/null 2>&1
          
          # Make script executable and run it with sudo
          ssh -p ${{ inputs.ssh_port }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            ${ADMIN_USER}@${{ steps.droplet-ip.outputs.ip }} \
            "chmod +x /tmp/setup-application.sh && \
             sudo /tmp/setup-application.sh \
               '${{ inputs.domain_name }}' \
               '${{ inputs.app_port }}' \
               '${{ inputs.metrics_path }}' \
               '${{ secrets.SSH_PUBLIC_KEY }}'"
          
          # Generate username using the same logic as sanitize_domain() function
          DOMAIN="${{ inputs.domain_name }}"
          USERNAME=$(echo "$DOMAIN" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
          
          # Truncate to 32 characters max (Linux username limit)
          if [ ${#USERNAME} -gt 32 ]; then
            USERNAME=$(echo "$USERNAME" | cut -c1-32)
          fi
          echo "username=$USERNAME" >> $GITHUB_OUTPUT
          echo "âœ“ Application setup completed"
      

      
      - name: Save metadata to GitHub Variable
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "Saving deployment metadata to GitHub Variable..."
          
          # Source the helper functions
          source /tmp/metadata-helpers.sh
          
          # Use the same username that was generated in the setup-app step
          USERNAME="${{ steps.setup-app.outputs.username }}"
          
          # Create metadata JSON using jq to ensure proper formatting and escaping
          METADATA=$(jq -n \
            --arg droplet_id "${{ steps.create-droplet.outputs.droplet_id }}" \
            --arg droplet_name "${{ steps.droplet-name.outputs.name }}" \
            --arg droplet_ip "${{ steps.droplet-ip.outputs.ip }}" \
            --arg region "${{ inputs.region }}" \
            --arg size "${{ env.DROPLET_SIZE }}" \
            --arg created_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --argjson ssh_port "${{ inputs.ssh_port }}" \
            --arg ssh_user "${{ inputs.ssh_authorized_username }}" \
            --arg domain "${{ inputs.domain_name }}" \
            --arg username "$USERNAME" \
            --argjson app_port "${{ inputs.app_port }}" \
            --arg metrics_path "${{ inputs.metrics_path }}" \
            --arg service_name "app-$USERNAME" \
            '{
              "droplet": {
                "id": $droplet_id,
                "name": $droplet_name,
                "ip": $droplet_ip,
                "region": $region,
                "size": $size,
                "created_at": $created_at,
                "ssh_port": $ssh_port,
                "ssh_user": $ssh_user
              },
              "applications": [
                {
                  "domain": $domain,
                  "username": $username,
                  "port": $app_port,
                  "metrics_path": $metrics_path,
                  "service_name": $service_name
                }
              ]
            }')
          

          
          # Update metadata using helper function (suppress output to avoid logging sensitive data)
          if update_metadata "$METADATA" > /dev/null 2>&1; then
            echo "âœ“ Metadata saved to DEPLOYMENT_METADATA variable"
          else
            echo "Error: Failed to save metadata"
            echo "Note: Detailed error information is suppressed to protect sensitive data"
            exit 1
          fi
      
      - name: Deployment summary
        run: |
          echo "## ðŸŽ‰ Droplet Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Droplet Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Droplet ID**: ${{ steps.create-droplet.outputs.droplet_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: ${{ inputs.region }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Size**: ${{ env.DROPLET_SIZE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain**: ${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Port**: ${{ inputs.app_port }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Metrics Path**: ${{ inputs.metrics_path }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”’ Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Sensitive deployment information (IP address, SSH port, usernames) is stored securely in GitHub Variables." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To access deployment details, use other workflows:" >> $GITHUB_STEP_SUMMARY
          echo "- **Setup SSL**: Automatically retrieves droplet IP from metadata" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy**: Automatically retrieves connection details from metadata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: This approach protects your infrastructure from exposure in public repositories." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš ï¸ Important: Configure DNS Records" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Your droplet is ready, but you need to configure DNS records manually:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Add these DNS records with your domain registrar:**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Add an **A record** for \`${{ inputs.domain_name }}\` pointing to your droplet IP" >> $GITHUB_STEP_SUMMARY
          echo "2. Add an **A record** for \`www.${{ inputs.domain_name }}\` pointing to your droplet IP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: DNS propagation typically takes 5-10 minutes, but can take up to 48 hours." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Configure DNS records** (see instructions above)" >> $GITHUB_STEP_SUMMARY
          echo "2. **Wait for DNS propagation** - Verify with:" >> $GITHUB_STEP_SUMMARY
          echo '   ```bash' >> $GITHUB_STEP_SUMMARY
          echo "   dig +short ${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
          echo '   ```' >> $GITHUB_STEP_SUMMARY
          echo "3. **Setup SSL certificate** - Run the setup-ssl workflow:" >> $GITHUB_STEP_SUMMARY
          echo "   - Go to Actions â†’ Setup SSL" >> $GITHUB_STEP_SUMMARY
          echo "   - Enter domain: \`${{ inputs.domain_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "   - Leave droplet IP empty (will be retrieved from metadata automatically)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "4. **Deploy your application** - Create a release tag (e.g., v1.0.0)" >> $GITHUB_STEP_SUMMARY
          echo "5. **Access your application** at: https://${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
