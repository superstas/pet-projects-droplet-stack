name: Create Droplet

on:
  workflow_dispatch:
    inputs:
      domain_name:
        description: 'Domain name for the application (e.g., example.com)'
        required: true
        type: string
      region:
        description: 'DigitalOcean region (e.g., nyc1, sfo3, ams3, lon1, fra1, sgp1)'
        required: true
        type: choice
        options:
          - nyc1
          - nyc2
          - nyc3
          - sfo2
          - sfo3
          - ams3
          - sgp1
          - lon1
          - fra1
          - tor1
          - blr1
          - syd1
          - atl1
      app_port:
        description: 'Application port (default: 9000)'
        required: false
        type: number
        default: 9000
      metrics_path:
        description: 'Metrics endpoint path (default: /metrics)'
        required: false
        type: string
        default: '/metrics'
      ssh_authorized_keys:
        description: 'SSH public keys for admin user (one per line, optional - uses secret if not provided)'
        required: false
        type: string
      ssh_authorized_username:
        description: 'Username for SSH admin access (default: admin)'
        required: false
        type: string
        default: 'admin'
      ssh_port:
        description: 'SSH port for server access (default: 53222)'
        required: false
        type: number
        default: 53222

env:
  DROPLET_SIZE: s-1vcpu-512mb-10gb
  DROPLET_IMAGE: debian-12-x64
  DROPLET_TAG: managed-by-github

jobs:
  create-droplet:
    name: Create and Configure Droplet
    runs-on: ubuntu-latest
    permissions:
      contents: read   # Required for reading repository content
      actions: write   # Required for managing GitHub Actions Variables
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Process and mask sensitive inputs
        run: |
          echo "Processing sensitive inputs..."
          
          # Read all sensitive values from inputs
          SSH_PORT=$(cat $GITHUB_EVENT_PATH | jq -r '.inputs.ssh_port')
          SSH_USERNAME=$(cat $GITHUB_EVENT_PATH | jq -r '.inputs.ssh_authorized_username')
          SSH_KEYS=$(cat $GITHUB_EVENT_PATH | jq -r '.inputs.ssh_authorized_keys')
          
          # Store in temporary files for reuse across steps
          echo "$SSH_PORT" > /tmp/ssh_port
          echo "$SSH_USERNAME" > /tmp/admin_username
          if [ "$SSH_KEYS" != "null" ] && [ -n "$SSH_KEYS" ]; then
            echo "$SSH_KEYS" > /tmp/ssh_keys
          fi
          
          echo "âœ“ Sensitive inputs processed and masked"
      
      - name: Setup metadata helpers
        run: |
          cp infra/scripts/metadata-helpers.sh /tmp/metadata-helpers.sh
          chmod +x /tmp/metadata-helpers.sh
          echo "âœ“ Metadata copied"
      
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}
      
      - name: Validate inputs
        run: |
          echo "Validating inputs..."
          
          # Validate domain name (supports subdomains like test.example.com)
          if [[ ! "${{ inputs.domain_name }}" =~ ^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]]; then
            echo "Error: Invalid domain name format"
            echo "Domain must be a valid FQDN (e.g., example.com or test.example.com)"
            exit 1
          fi
          
          # Validate port
          if [ "${{ inputs.app_port }}" -lt 1024 ] || [ "${{ inputs.app_port }}" -gt 65535 ]; then
            echo "Error: Port must be between 1024 and 65535"
            exit 1
          fi
          
          echo "âœ“ All inputs are valid"
      
      - name: Validate SSH port
        run: |
          echo "Validating SSH port..."
          SSH_PORT=$(cat /tmp/ssh_port)
          
          # Check port range (1024-65535)
          if [ "$SSH_PORT" -lt 1024 ] || [ "$SSH_PORT" -gt 65535 ]; then
            echo "Error: SSH port must be between 1024 and 65535"
            echo "Please provide a valid port number in the allowed range"
            exit 1
          fi
          
          echo "âœ“ SSH port is valid"
      
      - name: Generate droplet name
        id: droplet-name
        run: |
          # Generate a unique droplet name from domain
          DOMAIN="${{ inputs.domain_name }}"
          SANITIZED=$(echo "$DOMAIN" | sed 's/[^a-z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
          DROPLET_NAME="droplet-${SANITIZED}"
          echo "name=$DROPLET_NAME" >> $GITHUB_OUTPUT
          echo "Generated droplet name: $DROPLET_NAME"
      
      - name: Add SSH key to DigitalOcean
        run: |
          # Check if SSH key already exists
          KEY_NAME="github-actions-${{ github.repository_owner }}"
          
          # Try to find existing key (suppress output to prevent ID exposure)
          EXISTING_KEY_ID=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$KEY_NAME" | awk '{print $1}' 2>/dev/null || true)
          
          if [ -n "$EXISTING_KEY_ID" ]; then
            echo "âœ“ SSH key already exists and will be reused"
            echo "$EXISTING_KEY_ID" > /tmp/ssh_key_id
          else
            # Add new SSH key
            echo "Adding new SSH key..."
            echo "${{ secrets.SSH_PUBLIC_KEY }}" > /tmp/ssh_key.pub
            
            KEY_ID=$(doctl compute ssh-key import "$KEY_NAME" \
              --public-key-file /tmp/ssh_key.pub \
              --format ID --no-header 2>/dev/null)
            
            # Mask and store key ID in temporary file
            echo "::add-mask::$KEY_ID"
            echo "$KEY_ID" > /tmp/ssh_key_id
            echo "âœ“ SSH key added successfully"
            
            rm /tmp/ssh_key.pub
          fi
      
      - name: Prepare cloud-init with admin user
        run: |
          echo "Preparing cloud-init configuration..."
          
          # Read values from temporary files (already masked)
          ADMIN_USERNAME=$(cat /tmp/admin_username)
          SSH_PORT=$(cat /tmp/ssh_port)
          
          # Determine which SSH keys to use
          if [ -f /tmp/ssh_keys ]; then
            ADMIN_SSH_KEYS=$(cat /tmp/ssh_keys)
          else
            ADMIN_SSH_KEYS="${{ secrets.SSH_PUBLIC_KEY }}"
          fi
          
          # Create temporary cloud-init with configured SSH port
          cp infra/templates/cloud-init.yml /tmp/cloud-init-custom.yml
          
          # Replace hardcoded SSH port with configured port (suppress sed output)
          sed -i "s/Port 53222/Port ${SSH_PORT}/" /tmp/cloud-init-custom.yml 2>/dev/null
          sed -i "s/ufw limit 53222\\/tcp/ufw limit ${SSH_PORT}\\/tcp/" /tmp/cloud-init-custom.yml 2>/dev/null
          
          # Add admin user configuration
          cat >> /tmp/cloud-init-custom.yml << EOF

          # Create admin user for server administration
          users:
            - name: ${ADMIN_USERNAME}
              groups: sudo
              shell: /bin/bash
              sudo: ['ALL=(ALL) NOPASSWD:ALL']
              ssh_authorized_keys:
          EOF
          
          # Add SSH keys (one per line)
          echo "$ADMIN_SSH_KEYS" | while IFS= read -r key; do
            if [ -n "$key" ]; then
              echo "      - $key" >> /tmp/cloud-init-custom.yml
            fi
          done
          
          echo "âœ“ Cloud-init prepared with admin user configuration"
          echo "âœ“ SSH port configured successfully"
      
      - name: Create droplet with cloud-init
        run: |
          echo "Creating droplet..."
          
          # Read SSH key ID from temporary file (value is masked)
          SSH_KEY_ID=$(cat /tmp/ssh_key_id)
          
          # Create droplet and capture output (suppress verbose output to prevent ID exposure)
          DROPLET_ID=$(doctl compute droplet create "${{ steps.droplet-name.outputs.name }}" \
            --size "${{ env.DROPLET_SIZE }}" \
            --image "${{ env.DROPLET_IMAGE }}" \
            --region "${{ inputs.region }}" \
            --ssh-keys "$SSH_KEY_ID" \
            --tag-name "${{ env.DROPLET_TAG }}" \
            --user-data-file /tmp/cloud-init-custom.yml \
            --wait \
            --format ID \
            --no-header 2>/dev/null)
          
          echo "$DROPLET_ID" > /tmp/droplet_id
          echo "âœ“ Droplet created successfully"
      
      - name: Wait for droplet to be active and get IP
        run: |
          echo "Waiting for droplet to become active..."
          
          # Read droplet ID from temporary file (value is masked)
          DROPLET_ID=$(cat /tmp/droplet_id)
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header 2>/dev/null)
            
            if [ "$STATUS" = "active" ]; then
              echo "âœ“ Droplet is active"
              break
            fi
            
            echo "Droplet status: $STATUS (attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
            sleep 5
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Error: Droplet did not become active in time"
            exit 1
          fi
          
          IP_ADDRESS=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header 2>/dev/null)
          echo "$IP_ADDRESS" > /tmp/droplet_ip
          echo "âœ“ Droplet IP address resolved successfully"
      
      - name: Wait for SSH to be available
        run: |
          # Get connection details from temporary files (values are masked)
          SSH_PORT=$(cat /tmp/ssh_port)
          IP=$(cat /tmp/droplet_ip)
          
          echo "Waiting for SSH to become available..."
          
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if timeout 5 bash -c "cat < /dev/null > /dev/tcp/$IP/$SSH_PORT" 2>/dev/null; then
              echo "âœ“ SSH is available"
              break
            fi
            
            echo "Waiting for SSH... (attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Error: SSH did not become available in time"
            exit 1
          fi
      
      - name: Setup SSH key for connection
        run: |
          # Get connection details from temporary files (values are masked)
          SSH_PORT=$(cat /tmp/ssh_port)
          IP=$(cat /tmp/droplet_ip)
          
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Add to known_hosts (suppress output to prevent IP/port exposure)
          ssh-keyscan -p $SSH_PORT -H $IP >> ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Wait for cloud-init to complete
        run: |
          # Get connection details from temporary files (values are masked)
          IP=$(cat /tmp/droplet_ip)
          ADMIN_USER=$(cat /tmp/admin_username)
          SSH_PORT=$(cat /tmp/ssh_port)
          
          echo "Waiting for cloud-init to complete..."
          echo "Using configured admin user"
          
          # Use cloud-init status --wait to wait for completion (with timeout)
          # This ensures all packages are installed AND all runcmd scripts have executed
          ssh -p $SSH_PORT \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=5 \
            -o ServerAliveCountMax=3 \
            ${ADMIN_USER}@$IP \
            "sudo cloud-init status --wait --long" || {
              echo "Error: cloud-init did not complete successfully"
              echo "Checking cloud-init status..."
              ssh -p $SSH_PORT \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o LogLevel=ERROR \
                ${ADMIN_USER}@$IP \
                "sudo cloud-init status --long" || true
              exit 1
            }
          
          echo "âœ“ Cloud-init completed successfully"
          
          # Verify nginx configuration exists
          echo "Verifying nginx configuration..."
          ssh -p $SSH_PORT \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            ${ADMIN_USER}@$IP \
            "sudo test -f /etc/nginx/nginx.conf && sudo nginx -t" || {
              echo "Error: Nginx configuration is missing or invalid"
              exit 1
            }
          
          echo "âœ“ Nginx is properly configured"
      
      - name: Copy setup script to droplet
        run: |
          # Get connection details from temporary files (values are masked)
          ADMIN_USER=$(cat /tmp/admin_username)
          SSH_PORT=$(cat /tmp/ssh_port)
          IP=$(cat /tmp/droplet_ip)
          
          echo "Copying setup-application.sh to droplet..."
          
          scp -P $SSH_PORT \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            infra/scripts/setup-application.sh \
            ${ADMIN_USER}@$IP:/tmp/setup-application.sh
          
          echo "âœ“ Script copied successfully"
      
      - name: Run application setup script
        id: setup-app
        run: |
          # Get connection details from temporary files (values are masked)
          ADMIN_USER=$(cat /tmp/admin_username)
          SSH_PORT=$(cat /tmp/ssh_port)
          IP=$(cat /tmp/droplet_ip)
          
          echo "Running application setup..."
          
          # Make script executable and run it with sudo
          ssh -p $SSH_PORT \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            ${ADMIN_USER}@$IP \
            "chmod +x /tmp/setup-application.sh && \
             sudo /tmp/setup-application.sh \
               '${{ inputs.domain_name }}' \
               '${{ inputs.app_port }}' \
               '${{ inputs.metrics_path }}' \
               '${{ secrets.SSH_PUBLIC_KEY }}'"
          
          # Generate username using the same logic as sanitize_domain() function
          DOMAIN="${{ inputs.domain_name }}"
          USERNAME=$(echo "$DOMAIN" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
          
          # Truncate to 32 characters max (Linux username limit)
          if [ ${#USERNAME} -gt 32 ]; then
            USERNAME=$(echo "$USERNAME" | cut -c1-32)
          fi
          echo "username=$USERNAME" >> $GITHUB_OUTPUT
          echo "âœ“ Application setup completed"
      

      
      - name: Save metadata to GitHub Variable
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "Saving deployment metadata to GitHub Variable..."
          
          # Source the helper functions
          source /tmp/metadata-helpers.sh
          
          # Use the same username that was generated in the setup-app step
          USERNAME="${{ steps.setup-app.outputs.username }}"
          
          # Read sensitive data from temporary files (values are masked)
          DROPLET_ID=$(cat /tmp/droplet_id)
          DROPLET_IP=$(cat /tmp/droplet_ip)
          SSH_PORT=$(cat /tmp/ssh_port)
          ADMIN_USER=$(cat /tmp/admin_username)
          
          # Create metadata JSON using jq to ensure proper formatting and escaping
          METADATA=$(jq -n \
            --arg droplet_id "$DROPLET_ID" \
            --arg droplet_name "${{ steps.droplet-name.outputs.name }}" \
            --arg droplet_ip "$DROPLET_IP" \
            --arg region "${{ inputs.region }}" \
            --arg size "${{ env.DROPLET_SIZE }}" \
            --arg created_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --argjson ssh_port "$SSH_PORT" \
            --arg ssh_user "$ADMIN_USER" \
            --arg domain "${{ inputs.domain_name }}" \
            --arg username "$USERNAME" \
            --argjson app_port "${{ inputs.app_port }}" \
            --arg metrics_path "${{ inputs.metrics_path }}" \
            --arg service_name "app-$USERNAME" \
            '{
              "droplet": {
                "id": $droplet_id,
                "name": $droplet_name,
                "ip": $droplet_ip,
                "region": $region,
                "size": $size,
                "created_at": $created_at,
                "ssh_port": $ssh_port,
                "ssh_user": $ssh_user
              },
              "applications": [
                {
                  "domain": $domain,
                  "username": $username,
                  "port": $app_port,
                  "metrics_path": $metrics_path,
                  "service_name": $service_name
                }
              ]
            }')
          

          
          # Update metadata using helper function (suppress output to avoid logging sensitive data)
          if update_metadata "$METADATA" > /dev/null 2>&1; then
            echo "âœ“ Metadata saved to DEPLOYMENT_METADATA variable"
          else
            echo "Error: Failed to save metadata"
            echo "Note: Detailed error information is suppressed to protect sensitive data"
            exit 1
          fi
          
          # Clean up sensitive temporary files for security
          rm -f /tmp/droplet_id /tmp/droplet_ip /tmp/ssh_key_id /tmp/ssh_port /tmp/admin_username 2>/dev/null || true
      
      - name: Deployment summary
        run: |
          echo "## ðŸŽ‰ Droplet Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Droplet Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: ${{ inputs.region }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Size**: ${{ env.DROPLET_SIZE }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain**: ${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Port**: ${{ inputs.app_port }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Metrics Path**: ${{ inputs.metrics_path }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Sensitive deployment information (IP address, SSH port, usernames) is stored securely in GitHub Variables." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To access deployment details, use other workflows:" >> $GITHUB_STEP_SUMMARY
          echo "- **Setup SSL**: Automatically retrieves droplet IP from metadata" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy**: Automatically retrieves connection details from metadata" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: This approach protects your infrastructure from exposure in public repositories." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš ï¸ Important: Configure DNS Records" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Your droplet is ready, but you need to configure DNS records manually:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Add these DNS records with your domain registrar:**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Add an **A record** for \`${{ inputs.domain_name }}\` pointing to your droplet IP" >> $GITHUB_STEP_SUMMARY
          echo "2. Add an **A record** for \`www.${{ inputs.domain_name }}\` pointing to your droplet IP (only for root domains, not subdomains)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: DNS propagation typically takes 5-10 minutes, but can take up to 48 hours." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Configure DNS records** (see instructions above)" >> $GITHUB_STEP_SUMMARY
          echo "2. **Wait for DNS propagation** - Verify with:" >> $GITHUB_STEP_SUMMARY
          echo '   ```bash' >> $GITHUB_STEP_SUMMARY
          echo "   dig +short ${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
          echo '   ```' >> $GITHUB_STEP_SUMMARY
          echo "3. **Setup SSL certificate** - Run the setup-ssl workflow:" >> $GITHUB_STEP_SUMMARY
          echo "   - Go to Actions â†’ Setup SSL" >> $GITHUB_STEP_SUMMARY
          echo "   - Enter domain: \`${{ inputs.domain_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "   - Leave droplet IP empty (will be retrieved from metadata automatically)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "4. **Deploy your application** - Create a release tag (e.g., v1.0.0)" >> $GITHUB_STEP_SUMMARY
          echo "5. **Access your application** at: https://${{ inputs.domain_name }}" >> $GITHUB_STEP_SUMMARY
